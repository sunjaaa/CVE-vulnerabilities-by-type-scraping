const helper = require("./helper");

const getData = async (CVEwebSite, CVEList) => {
  //! for문을 무조건 실행하기위한 변수
  const run = 1;

  if (run === 1) {
    for (let num = 2; num <= 100; num = num + 2) {
      //! 한 페이지에서 가져온 데이터
      let pageData = {};

      const descriptionNum = num + 1;

      try {
        const number = await CVEwebSite.$eval(
          "#vulnslisttable > tbody > tr:nth-child(" +
            num +
            ") > td:nth-child(1)",
          (el) => el.textContent
        );
        pageData.number = helper.removeNewLine(number);
      } catch (e) {
        console.error("번호가 존재하지 않습니다.", e);
        throw e;
      }

      try {
        const cveID = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(2) > a`,
          (el) => el.textContent
        );
        pageData.cveID = cveID;
      } catch (e) {
        console.error("crawler.js cveID", e);
        throw e;
      }

      try {
        const cwdID = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(3) > a`,
          (el) => el.textContent
        );
        pageData.cwdID = cwdID;
      } catch (e) {
        pageData.cwdID = "";
      }

      try {
        const _ofExploits = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(4) > a`,
          (el) => el.textContent
        );
        pageData._ofExploits = _ofExploits;
      } catch (e) {
        pageData._ofExploits = "";
      }

      try {
        const vulnerabilityTypes = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(5)`,
          (el) => el.textContent
        );
        pageData.vulnerabilityTypes = helper.removeNewLine(vulnerabilityTypes);
      } catch (e) {
        pageData.vulnerabilityTypes = "";
      }

      try {
        const publishDate = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(6)`,
          (el) => el.textContent
        );
        pageData.publishDate = publishDate;
      } catch (e) {
        pageData.publishDate = "";
      }

      try {
        const updateDate = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(7)`,
          (el) => el.textContent
        );
        pageData.updateDate = updateDate;
      } catch (e) {
        pageData.updateDate = "";
      }

      try {
        const score = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(8) > div`,
          (el) => el.textContent
        );
        pageData.score = score;
      } catch (e) {
        pageData.score = "";
      }

      try {
        const gainedAccessLevel = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(9)`,
          (el) => el.textContent
        );
        pageData.gainedAccessLevel = gainedAccessLevel;
      } catch (e) {
        pageData.gainedAccessLevel = "";
      }

      try {
        const access = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(10)`,
          (el) => el.textContent
        );
        pageData.access = access;
      } catch (e) {
        pageData.access = "";
      }

      try {
        const complexity = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(11)`,
          (el) => el.textContent
        );
        pageData.complexity = complexity;
      } catch (e) {
        pageData.complexity = "";
      }

      try {
        const authentication = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(12)`,
          (el) => el.textContent
        );
        pageData.authentication = authentication;
      } catch (e) {
        pageData.authentication = "";
      }

      try {
        const conf = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(13)`,
          (el) => el.textContent
        );
        pageData.conf = conf;
      } catch (e) {
        pageData.conf = "";
      }

      try {
        const integ = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(14)`,
          (el) => el.textContent
        );
        pageData.integ = integ;
      } catch (e) {
        pageData.integ = "";
      }

      try {
        const avail = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${num}) > td:nth-child(15)`,
          (el) => el.textContent
        );
        pageData.avail = avail;
      } catch (e) {
        pageData.avail = "";
      }

      try {
        const description = await CVEwebSite.$eval(
          `#vulnslisttable > tbody > tr:nth-child(${descriptionNum}) > td`,
          (el) => el.textContent
        );
        pageData.description = helper.removeNewLine(description);
      } catch (e) {
        pageData.description = "";
      }

      CVEList.push(pageData);
      console.log("********PUSHED********");
    }
  }
};

/**
 * setInterval 함수를 멈추는 함수
 * @param {*} intervalID interval이 반환하는 ID
 */
const stopInterval = async (intervalID) => {
  clearInterval(intervalID);
  console.log("INTERVAL STOPED");
};

exports.getData = getData;
exports.stopInterval = stopInterval;
